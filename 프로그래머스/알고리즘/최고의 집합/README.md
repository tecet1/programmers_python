
## 문제링크
[최고의 집](https://school.programmers.co.kr/learn/courses/30/lessons/12938)
## 첫번째 시도
풀 엄두가 안나서 그냥 ai한테 아이디어좀 달라고 했음

## 🧭 원소의 곱을 최대로 만드는 방향성 (수학적 최적화)

주어진 문제는 **원소의 개수 $n$이 고정**되어 있고, **원소들의 합 $s$가 고정**된 자연수 집합 중에서, **원소들의 곱 $P$를 최대**로 만드는 방법을 찾는 것입니다.

$n$의 크기가 최대 10,000으로 매우 크기 때문에, 단순한 탐색이나 완전 탐색($O(n^2)$ 이상)은 불가능하며 **수학적 최적화 원리**를 사용하여 $O(1)$ 또는 $O(n)$ 수준의 알고리즘으로 해결해야 합니다.

### 1. 🥇 핵심 원리: '균등 분배'의 법칙

두 수 $a$와 $b$의 **합이 일정**할 때 ($a+b=S$), 그 **곱 $a \times b$가 최대**가 되는 지점은 $a$와 $b$의 차이가 **가장 작을 때**입니다 (즉, $a \approx b$).

이 원리는 원소가 $n$개일 때도 확장되어 적용됩니다. **합이 $S$인 $n$개의 원소의 곱을 최대로 만들려면, 이 $n$개의 원소들을 최대한 균등하게 분배**해야 합니다.

-   예시: 합이 10일 때,
    
    -   $1+9=10$, 곱: $9$
        
    -   $5+5=10$, 곱: $25$ (최대)
        

### 2. 🥈 균등 분배를 위한 계산

합 $s$를 원소의 개수 $n$으로 나누어 몫($q$)과 나머지($r$)를 구합니다.

$$s = q \times n + r \quad (\text{단, } 0 \le r < n)$$

-   **몫 ($q$)**: 집합의 대부분의 원소가 가져야 할 기본 값입니다.
    
-   **나머지 ($r$)**: $s$를 $n$으로 나눈 후 남은 값으로, 이 $r$을 **$r$개의 원소**에 1씩 나누어 주어 합을 $s$로 정확히 맞춥니다.
    

### 3. 🥉 집합 구성 전략

곱을 최대로 만들기 위한 최적의 집합은 다음과 같이 구성됩니다.

1.  **큰 원소의 개수**: 나머지 $r$의 개수만큼, 기본 몫 $q$에 1을 더한 값 **$(q + 1)$**을 원소로 가집니다.
    
2.  **작은 원소의 개수**: 나머지 $n - r$의 개수만큼, 기본 몫 **$q$**를 원소로 가집니다.
    

-   **예시**: $s=11$, $n=3$ 일 때
    
    -   $11 / 3 = 3$ 나머지 $2$ ($q=3, r=2$)
        
    -   $r=2$ 개는 $3+1 = 4$를 가짐 $\rightarrow$ 원소 2개는 **4**
        
    -   $n-r = 1$ 개는 $3$을 가짐 $\rightarrow$ 원소 1개는 **3**
        
    -   최적 집합: $\{3, 4, 4\}$. 합 $3+4+4=11$, 곱 $3 \times 4 \times 4 = 48$ (최대)
        

----------

## ⚠️ 예외 및 추가 고려 사항

1.  **$s < n$ 인 경우**: 원소의 합 $s$가 개수 $n$보다 작으면, 원소 중 일부는 0이 되거나 (문제에서 자연수 집합을 요구한다면 성립 불가능) 곱이 0이 되어 최댓값을 가질 수 없습니다. **자연수 집합**이라는 조건 하에서는 $s$가 $n$보다 작을 경우 **집합을 구성할 수 없음**을 반환해야 합니다 (문제 요구사항에 따라 빈 리스트나 `-1` 등).
    
2.  **최종 반환**: 문제에서 **집합(set)**의 원소를 요구할 경우, 위에서 계산한 $r$개의 $(q+1)$과 $(n-r)$개의 $q$를 담은 리스트를 반환하면 됩니다.
    

### 🔑 결론적 방향성

코드는 **나눗셈 연산**($s // n$)과 **나머지 연산**($s \% n$)을 통해 $q$와 $r$을 단 한 번 계산하고, 이를 바탕으로 $O(n)$ 시간에 원소 $n$개를 생성하여 리스트를 반환하는 방식으로 구현되어야 합니다.

## 💡수정된 코드
```
def solution(n, s):
    answer = []
    #n = 원소 개수, s = 원소들의 합
    quotient = s//n
    remainder = s%n
    if quotient <= 0:
        return[-1]
    
    for i in range(remainder):
        answer.append(quotient+1)
    for i in range(n-remainder):
        answer.append(quotient)
    
    answer.sort()
    return answer
```

## 분석
### 로직
이건 아이디어만 알면 쉬운데 그걸 떠올리는게 어려운 타입의 문제인듯 (물론 내가 어려운..)
이런건 그냥 많이 풀어보는게 능사다..

### 문법
해당사항 없음
> Written with [StackEdit](https://stackedit.io/).
